<!DOCTYPE html>
<html lang="fa">
<head>
<meta charset="utf-8"/>
<title>QR Pose — Stabilized (jsQR)</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<style>
  body{margin:0;background:#0b0b0b;color:#e6e6e6;font-family:system-ui,Segoe UI,Roboto,Arial}
  video, canvas{position:fixed; top:0; left:0; width:100%; height:100%; object-fit:cover}
  #ui{position:fixed; left:8px; top:8px; z-index:60; background:rgba(0,0,0,0.6); padding:10px; border-radius:10px; width:320px}
  label{display:block; font-size:13px; margin-top:6px; color:#cfcfcf}
  .small{font-size:12px;color:#bdbdbd}
  pre{white-space:pre-wrap; font-family:monospace; font-size:12px; color:#e6e6e6}
  button{margin-top:6px}
  .statusLine{font-family:monospace; font-size:13px; color:#ffd86b}
</style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div id="status" class="small">درحال آماده‌سازی...</div>

    <label>marker size (mm): <input id="markerSize" type="number" value="60"></label>
    <label>Camera FOV horiz (deg) — یا وارد کن fx(px): <input id="fov" type="number" value="60"></label>
    <label>fx (px) (اختیاری - خالی بذار تا FOV استفاده شود): <input id="fx" type="text" placeholder="مثلا 800"></label>

    <hr style="border-color:rgba(255,255,255,0.06)"/>

    <div class="small">Stabilization:</div>
    <label>lockThreshold (frames to lock): <input id="lockThreshold" type="number" min="1" max="10" value="3"></label>
    <label>loseTimeout (frames to unlock): <input id="loseTimeout" type="number" min="1" max="60" value="8"></label>
    <label>alpha (EMA 0..1): <input id="alpha" type="number" step="0.05" min="0.0" max="1" value="0.6"></label>
    <label>iouThreshold (0..1): <input id="iouThreshold" type="number" step="0.05" min="0" max="1" value="0.25"></label>
    <label>maxCenterShift (px): <input id="maxShift" type="number" value="60"></label>

    <div style="margin-top:8px" class="statusLine" id="lockStatus">LOCKED: NO</div>

    <div style="margin-top:8px">
      <div class="small">Outputs:</div>
      <pre id="outText">هیچ</pre>
    </div>

    <button id="calBtn">recompute intrinsics (K)</button>
  </div>

  <!-- jsQR -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

<script>
/* qr_pose_stable.html
   - Uses jsQR for corners
   - Computes homography -> R,t (like before)
   - Adds temporal stabilization: lock, EMA smoothing, velocity prediction, unlock policy
*/

// DOM
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');
const outText = document.getElementById('outText');
const lockStatus = document.getElementById('lockStatus');

const markerSizeInput = document.getElementById('markerSize');
const fovInput = document.getElementById('fov');
const fxInput = document.getElementById('fx');
const calBtn = document.getElementById('calBtn');

const lockThresholdInput = document.getElementById('lockThreshold');
const loseTimeoutInput = document.getElementById('loseTimeout');
const alphaInput = document.getElementById('alpha');
const iouThresholdInput = document.getElementById('iouThreshold');
const maxShiftInput = document.getElementById('maxShift');

let K = null, Kinv = null;

// recompute K when button pressed or on startup
calBtn.onclick = computeKandInv;

async function startCamera(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
    video.srcObject = stream;
    await video.play();
    status.innerText = 'دوربین آماده';
    computeKandInv();
    requestAnimationFrame(tick);
  } catch(e){
    status.innerText = 'خطا در دسترسی دوربین: ' + e.message;
    console.error(e);
  }
}
startCamera();

function computeKandInv(){
  const canvasW = video.videoWidth || window.innerWidth;
  const canvasH = video.videoHeight || window.innerHeight;
  const cx = canvasW / 2;
  const cy = canvasH / 2;
  let fx = null, fy = null;
  const fxVal = parseFloat(fxInput.value);
  if(!isNaN(fxVal) && fxVal > 0){
    fx = fxVal; fy = fxVal;
  } else {
    const fov = parseFloat(fovInput.value) || 60;
    fx = (canvasW/2) / Math.tan((fov*Math.PI/180)/2);
    fy = fx;
  }
  K = [[fx,0,cx],[0,fy,cy],[0,0,1]];
  Kinv = invert3(K);
  console.log('K computed', K);
}

/* ---------- linear algebra helpers (same as before) ---------- */
function invert3(M){
  const a=M[0][0], b=M[0][1], c=M[0][2];
  const d=M[1][0], e=M[1][1], f=M[1][2];
  const g=M[2][0], h=M[2][1], i=M[2][2];
  const A = e*i - f*h;
  const B = -(d*i - f*g);
  const C = d*h - e*g;
  const D = -(b*i - c*h);
  const E = a*i - c*g;
  const F = -(a*h - b*g);
  const G = b*f - c*e;
  const H = -(a*f - c*d);
  const I = a*e - b*d;
  const det = a*A + b*B + c*C;
  if(Math.abs(det) < 1e-12) return null;
  const inv = [
    [A/det, D/det, G/det],
    [B/det, E/det, H/det],
    [C/det, F/det, I/det]
  ];
  return inv;
}
function mulMatVec(M, v){
  return [ M[0][0]*v[0] + M[0][1]*v[1] + M[0][2]*v[2],
           M[1][0]*v[0] + M[1][1]*v[1] + M[1][2]*v[2],
           M[2][0]*v[0] + M[2][1]*v[1] + M[2][2]*v[2] ];
}
function mulMatMat(A,B){
  const R = [];
  for(let i=0;i<3;i++){
    R[i]=[];
    for(let j=0;j<3;j++){
      let s=0;
      for(let k=0;k<3;k++) s+=A[i][k]*B[k][j];
      R[i][j]=s;
    }
  }
  return R;
}
function scaleVec(v, s){ return [v[0]*s, v[1]*s, v[2]*s]; }
function cross(a,b){ return [ a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0] ]; }
function normalizeVec(v){ const n = Math.hypot(v[0],v[1],v[2]) || 1; return [v[0]/n, v[1]/n, v[2]/n]; }

/* ---------- homography from 4 points ---------- */
function computeHomography(srcPts, dstPts){
  const A = [], b = [];
  for(let i=0;i<4;i++){
    const X = srcPts[i].x, Y = srcPts[i].y;
    const u = dstPts[i].x, v = dstPts[i].y;
    A.push([ X, Y, 1, 0, 0, 0, -u*X, -u*Y ]); b.push(u);
    A.push([ 0, 0, 0, X, Y, 1, -v*X, -v*Y ]); b.push(v);
  }
  const h8 = solveLinear8(A,b);
  if(!h8) return null;
  const h = [h8[0],h8[1],h8[2], h8[3],h8[4],h8[5], h8[6],h8[7], 1];
  return [[h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],h[8]]];
}
function solveLinear8(A,b){
  const n=8;
  const M = new Array(n);
  for(let i=0;i<n;i++){ M[i]=new Array(n+1); for(let j=0;j<n;j++) M[i][j]=A[i][j]; M[i][n]=b[i]; }
  for(let k=0;k<n;k++){
    let iMax=k; let maxVal=Math.abs(M[k][k]);
    for(let i=k+1;i<n;i++){ if(Math.abs(M[i][k])>maxVal){ maxVal=Math.abs(M[i][k]); iMax=i; } }
    if(Math.abs(M[iMax][k])<1e-12) return null;
    if(iMax!==k){ const tmp=M[k]; M[k]=M[iMax]; M[iMax]=tmp; }
    const pivot=M[k][k];
    for(let j=k;j<=n;j++) M[k][j]/=pivot;
    for(let i=0;i<n;i++){ if(i===k) continue; const factor=M[i][k]; if(Math.abs(factor)<1e-15) continue; for(let j=k;j<=n;j++) M[i][j]-=factor*M[k][j]; }
  }
  const x=new Array(n); for(let i=0;i<n;i++) x[i]=M[i][n]; return x;
}

/* ---------- decompose homography ---------- */
function decomposeHomography(H, K, Kinv){
  const h1=[H[0][0],H[1][0],H[2][0]];
  const h2=[H[0][1],H[1][1],H[2][1]];
  const h3=[H[0][2],H[1][2],H[2][2]];
  const Kinv_h1 = mulMatVec(Kinv, h1), Kinv_h2 = mulMatVec(Kinv, h2), Kinv_h3 = mulMatVec(Kinv, h3);
  const norm1 = Math.hypot(Kinv_h1[0],Kinv_h1[1],Kinv_h1[2]);
  const norm2 = Math.hypot(Kinv_h2[0],Kinv_h2[1],Kinv_h2[2]);
  const lambda = 1.0 / ((norm1 + norm2)/2.0);
  let r1 = scaleVec(Kinv_h1, lambda);
  let r2 = scaleVec(Kinv_h2, lambda);
  let t  = scaleVec(Kinv_h3, lambda);
  let r3 = cross(r1,r2);
  const r1n = normalizeVec(r1), r3n = normalizeVec(r3), r2n = cross(r3n,r1n);
  const R = [[r1n[0], r2n[0], r3n[0]],[r1n[1], r2n[1], r3n[1]],[r1n[2], r2n[2], r3n[2]]];
  return {R,t,lambda};
}
function rotToEulerZYX(R){
  let sy = -R[2][0];
  sy = Math.max(-1, Math.min(1, sy));
  const pitch = Math.asin(sy);
  const cosPitch = Math.cos(pitch);
  let roll=0, yaw=0;
  if(Math.abs(cosPitch) > 1e-6){
    roll = Math.atan2(R[2][1], R[2][2]);
    yaw  = Math.atan2(R[1][0], R[0][0]);
  } else { roll = 0; yaw = Math.atan2(-R[0][1], R[1][1]); }
  return [yaw, pitch, roll];
}

/* ---------- utilities ---------- */
function bboxFromCorners(pts){
  let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
  for(const p of pts){ if(p.x<minx)minx=p.x; if(p.y<miny)miny=p.y; if(p.x>maxx)maxx=p.x; if(p.y>maxy)maxy=p.y; }
  return {minx,miny,maxx,maxy};
}
function iouBoxes(a,b){
  if(!a||!b) return 0;
  const ix = Math.max(0, Math.min(a.maxx,b.maxx) - Math.max(a.minx,b.minx));
  const iy = Math.max(0, Math.min(a.maxy,b.maxy) - Math.max(a.miny,b.miny));
  const inter = ix * iy;
  const aarea = Math.max(0, a.maxx - a.minx) * Math.max(0, a.maxy - a.miny);
  const barea = Math.max(0, b.maxx - b.minx) * Math.max(0, b.maxy - b.miny);
  const union = aarea + barea - inter;
  if(union <= 0) return 0;
  return inter/union;
}
function centroid(pts){
  let sx=0, sy=0;
  for(const p of pts){ sx+=p.x; sy+=p.y; }
  return {x: sx/pts.length, y: sy/pts.length};
}
function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }

/* ---------- temporal stabilization state ---------- */
let lastTime = performance.now();
let locked = false;
let lockCount = 0;
let lostCount = 0;
const defaultLockThreshold = 3;
const defaultLoseTimeout = 8;
let smoothed = null; // {corners:[{x,y}..], t:[tx,ty,tz], eul:[yaw,pitch,roll]}
let velocity = null; // per-corner velocity in proc coords
let lastDetectedBBox = null;

/* ---------- pose processing ---------- */
function processPoseFromJsqr(codeLoc){
  const dstPts = [
    {x: codeLoc.topLeftCorner.x, y: codeLoc.topLeftCorner.y},
    {x: codeLoc.topRightCorner.x, y: codeLoc.topRightCorner.y},
    {x: codeLoc.bottomRightCorner.x, y: codeLoc.bottomRightCorner.y},
    {x: codeLoc.bottomLeftCorner.x, y: codeLoc.bottomLeftCorner.y}
  ];
  const s = parseFloat(markerSizeInput.value) || 60;
  const srcPts = [{x:0,y:0},{x:s,y:0},{x:s,y:s},{x:0,y:s}];
  const H = computeHomography(srcPts, dstPts);
  if(!H) return null;
  if(!K || !Kinv) computeKandInv();
  const dec = decomposeHomography(H, K, Kinv);
  const eul = rotToEulerZYX(dec.R).map(x => x * 180/Math.PI);
  return {corners: dstPts, H: H, R: dec.R, t: dec.t, eul: eul, lambda: dec.lambda};
}

/* ---------- tick loop ---------- */
function tick(){
  if(video.readyState < 2){ requestAnimationFrame(tick); return; }
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // get frame for jsQR (full resolution for accuracy)
  const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
  const code = jsQR(imgData.data, imgData.width, imgData.height, {inversionAttempts:"attemptBoth"});

  // read stabilization params
  const lockThreshold = parseInt(lockThresholdInput.value) || defaultLockThreshold;
  const loseTimeout = parseInt(loseTimeoutInput.value) || defaultLoseTimeout;
  const alpha = Math.max(0, Math.min(1, parseFloat(alphaInput.value) || 0.6));
  const iouThreshold = Math.max(0, Math.min(1, parseFloat(iouThresholdInput.value) || 0.25));
  const maxShift = Math.max(1, parseFloat(maxShiftInput.value) || 60);

  let currentPose = null;
  if(code){
    currentPose = processPoseFromJsqr(code.location);
  }

  // determine detected bbox
  let detectedBBox = null;
  if(currentPose) detectedBBox = bboxFromCorners(currentPose.corners);

  // compare with lastDetectedBBox via IoU or center distance
  let iou = 0;
  if(detectedBBox && lastDetectedBBox) iou = iouBoxes(detectedBBox, lastDetectedBBox);

  // also check center distance in pixels
  let centerShift = Infinity;
  if(currentPose && lastDetectedBBox){
    const c1 = centroid(currentPose.corners);
    const c2 = { x: (lastDetectedBBox.minx + lastDetectedBBox.maxx)/2, y: (lastDetectedBBox.miny + lastDetectedBBox.maxy)/2 };
    centerShift = dist(c1,c2);
  }

  // LOCK / UNLOCK logic
  if(currentPose && (lastDetectedBBox == null || iou >= iouThreshold || centerShift <= maxShift)){
    lockCount++;
  } else {
    lockCount = 0;
  }

  if(!locked){
    if(lockCount >= lockThreshold && currentPose){
      // lock now and init smoothing & velocity
      locked = true; lostCount = 0;
      smoothed = {
        corners: currentPose.corners.map(p => ({x:p.x, y:p.y})),
        t: [currentPose.t[0], currentPose.t[1], currentPose.t[2]],
        eul: [...currentPose.eul]
      };
      velocity = Array(4).fill().map(()=>({x:0,y:0}));
      lastDetectedBBox = detectedBBox;
      console.log('Locked on QR');
    }
  } else {
    // already locked
    if(currentPose && (iou >= iouThreshold || centerShift <= maxShift)){
      // update smoothing using EMA
      const newCorners = smoothed.corners.map((prev, i) => ({
        x: alpha * currentPose.corners[i].x + (1-alpha) * prev.x,
        y: alpha * currentPose.corners[i].y + (1-alpha) * prev.y
      }));
      // velocity = new - prev
      velocity = newCorners.map((nc, i) => ({ x: nc.x - smoothed.corners[i].x, y: nc.y - smoothed.corners[i].y }));
      // update translation and euler via EMA
      const newT = [
        alpha * currentPose.t[0] + (1-alpha) * smoothed.t[0],
        alpha * currentPose.t[1] + (1-alpha) * smoothed.t[1],
        alpha * currentPose.t[2] + (1-alpha) * smoothed.t[2]
      ];
      const newEul = currentPose.eul.map((v,i) => alpha * v + (1-alpha) * (smoothed.eul[i] || v));
      smoothed = { corners: newCorners, t: newT, eul: newEul };
      lastDetectedBBox = detectedBBox;
      lostCount = 0;
    } else {
      // detection missing or mismatch: predict using velocity
      if(smoothed && velocity){
        smoothed.corners = smoothed.corners.map((p,i) => ({ x: p.x + velocity[i].x, y: p.y + velocity[i].y }));
      }
      lostCount++;
      if(lostCount > loseTimeout){
        // unlock after continuous misses
        locked = false; lockCount = 0; lostCount = 0; lastDetectedBBox = null; smoothed = null; velocity = null;
        console.log('Unlocked due to lost');
      }
    }
  }

  // choose display corners: smoothed (if locked) else currentPose corners (if any)
  let displayCorners = null;
  if(locked && smoothed) displayCorners = smoothed.corners;
  else if(currentPose) displayCorners = currentPose.corners;

  // draw visuals
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  if(displayCorners){
    // polygon
    ctx.lineWidth = 4; ctx.strokeStyle = locked ? 'rgba(255,180,50,0.98)' : 'lime';
    ctx.beginPath();
    ctx.moveTo(displayCorners[0].x, displayCorners[0].y);
    for(let i=1;i<4;i++) ctx.lineTo(displayCorners[i].x, displayCorners[i].y);
    ctx.closePath(); ctx.stroke();
    // corners
    ctx.fillStyle = 'yellow'; for(const p of displayCorners){ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); }
  }

  // print outputs: if locked show smoothed t/eul else show "no stable pose"
  if(locked && smoothed){
    const t = smoothed.t; const e = smoothed.eul;
    outText.textContent = `LOCKED: YES\n\nTranslation (same unit as markerSize):\ntx: ${t[0].toFixed(2)}  ty: ${t[1].toFixed(2)}  tz: ${t[2].toFixed(2)}\n\nEuler (deg) (yaw, pitch, roll):\n${e.map(v=>v.toFixed(2)).join(', ')}\n\n(last detection IoU: ${iou.toFixed(2)}, center shift px: ${Math.round(centerShift)})`;
    lockStatus.textContent = 'LOCKED: YES';
    lockStatus.style.color = '#7ef0a6';
  } else if(currentPose){
    const t = currentPose.t; const e = currentPose.eul;
    outText.textContent = `LOCKED: NO (transient)\nTranslation:\ntx: ${t[0].toFixed(2)}  ty: ${t[1].toFixed(2)}  tz: ${t[2].toFixed(2)}\nEuler (deg): ${e.map(v=>v.toFixed(2)).join(', ')}`;
    lockStatus.textContent = 'LOCKED: NO';
    lockStatus.style.color = '#ffd86b';
  } else {
    outText.textContent = 'QR یافت نشد و قفل وجود ندارد.';
    lockStatus.textContent = 'LOCKED: NO';
    lockStatus.style.color = '#ff8a8a';
  }

  // fps (optional)
  const now = performance.now();
  const fps = Math.round(1000 / (now - lastTime + 1e-9));
  lastTime = now;
  status.innerText = `edgels: - (jsQR)  fps: ${fps}`;

  requestAnimationFrame(tick);
} // tick

</script>
</body>
</html>
