// --- detect valid quads ---
const quads = [];
const inBounds = (p) => (p.x>=0 && p.y>=0 && p.x<procW && p.y<procH);

for(let i=0;i<extended.length;i++){
  for(let j=i+1;j<extended.length;j++){
    for(let k=j+1;k<extended.length;k++){
      for(let m=k+1;m<extended.length;m++){
        const L = [extended[i], extended[j], extended[k], extended[m]];
        const pts=[];
        let ok=true;
        // سعی در گرفتن تقاطع‌های پیوسته بین خطوط
        for(let t=0;t<4;t++){
          const a=L[t], b=L[(t+1)%4];
          const p = intersect(a.p1,a.p2,b.p1,b.p2);
          if(!p || !inBounds(p)){ ok=false; break; }
          pts.push(p);
        }
        if(!ok || pts.length<4) continue;
        const ordered = orderQuad(pts);
        if(!isConvex(ordered)) continue;
        const area = Math.abs(polygonArea(ordered));
        if(area < (procW*procH)*0.005) continue; // حداقل مساحت منطقی
        const lens = []; 
        for(let ii=0;ii<4;ii++){ 
          const a=ordered[ii], b=ordered[(ii+1)%4]; 
          lens.push(Math.hypot(a.x-b.x,a.y-b.y)); 
        }
        const minL = Math.min(...lens), maxL = Math.max(...lens);
        if(minL < 30) continue;
        if(maxL/minL > 3.5) continue;

        // بررسی زاویه‌ها برای نزدیک بودن به 90 درجه
        let validAngles = true;
        for(let ii=0;ii<4;ii++){
          const a=ordered[ii], b=ordered[(ii+1)%4], c=ordered[(ii+2)%4];
          const v1={x:a.x-b.x, y:a.y-b.y}, v2={x:c.x-b.x, y:c.y-b.y};
          const ang=Math.acos((v1.x*v2.x+v1.y*v2.y)/(Math.hypot(v1.x,v1.y)*Math.hypot(v2.x,v2.y)+1e-6));
          const deg = ang*180/Math.PI;
          if(deg<60 || deg>120){ validAngles=false; break; }
        }
        if(!validAngles) continue;
        quads.push({pts:ordered, area});
      }
    }
  }
}

// فقط بزرگ‌ترین چهارضلعی را نمایش بده
ctx.clearRect(0,0,canvas.width,canvas.height);
ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

const scaleInv = canvas.width / procW;
ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(0,200,255,0.9)';
for(const L of extended){
  ctx.beginPath();
  ctx.moveTo(L.p1.x*scaleInv, L.p1.y*scaleInv);
  ctx.lineTo(L.p2.x*scaleInv, L.p2.y*scaleInv);
  ctx.stroke();
}

let printed = false;
if(quads.length > 0){
  quads.sort((a,b)=>b.area - a.area);
  const q = quads[0];
  const ptsDisp = q.pts.map(p => ({ x: p.x*scaleInv, y: p.y*scaleInv }));
  ctx.lineWidth = 5; ctx.strokeStyle = 'rgba(255,140,20,0.95)';
  ctx.beginPath();
  ctx.moveTo(ptsDisp[0].x, ptsDisp[0].y);
  for(let i=1;i<4;i++) ctx.lineTo(ptsDisp[i].x, ptsDisp[i].y);
  ctx.closePath(); ctx.stroke();
  ctx.fillStyle='yellow';
  for(const p of ptsDisp){ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); }
  coordsDiv.innerText = `گوشه‌ها (px):\nTL (${Math.round(ptsDisp[0].x)}, ${Math.round(ptsDisp[0].y)})\nTR (${Math.round(ptsDisp[1].x)}, ${Math.round(ptsDisp[1].y)})\nBR (${Math.round(ptsDisp[2].x)}, ${Math.round(ptsDisp[2].y)})\nBL (${Math.round(ptsDisp[3].x)}, ${Math.round(ptsDisp[3].y)})`;
  printed = true;
}

if(!printed){
  coordsDiv.innerText = 'مختصات: (هیچ)';
}

const now = performance.now();
const fps = Math.round(1000 / (now - lastTime));
lastTime = now;
statsDiv.innerText = `edgels:${edgels.length} lines:${topLines.length} quads:${quads.length} fps:${fps}`;

requestAnimationFrame(loop);
