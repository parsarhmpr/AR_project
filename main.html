<!DOCTYPE html>
<html lang="fa">
<head>
<meta charset="utf-8"/>
<title>Hirzer Debug AR (Enhanced)</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<style>
  body{margin:0;background:#111;color:#ddd;font-family:sans-serif}
  video,#mainCanvas{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover}
  #ui{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;z-index:20}
  .small{font-size:12px;color:#bbb}
  #smap{position:fixed;right:8px;top:8px;width:140px;height:100px;border:2px solid rgba(255,255,255,0.12);z-index:20}
  button,input[type=range]{font-size:13px}
</style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="mainCanvas"></canvas>

  <div id="ui">
    <div id="status">آماده‌سازی...</div>
    <div style="margin-top:6px">
      <button id="presetMobile">Preset: Mobile</button>
      <button id="presetPrinted">Preset: Printed</button>
      <button id="captureBtn">Capture</button>
      <button id="toggleDebug">Toggle Debug</button>
    </div>
    <div style="margin-top:6px">
      <label class="small">targetW: <span id="tv">480</span></label><br>
      <input id="targetW" type="range" min="240" max="960" value="480">
      <div class="small">gridStep: <span id="gs">8</span> <input id="gridStep" type="range" min="4" max="20" value="8"></div>
      <div class="small">edgelThr: <span id="et">12</span> <input id="edgelThr" type="range" min="4" max="60" value="12"></div>
      <div class="small">ransacIters: <span id="ri">350</span> <input id="ransacIter" type="range" min="60" max="800" value="350"></div>
      <div class="small">minSupport: <span id="ms">10</span> <input id="minSupport" type="range" min="4" max="32" value="10"></div>
    </div>
    <div style="margin-top:8px" class="small" id="stats">edgels:0 lines:0 quads:0 fps:0</div>
  </div>

  <canvas id="smap"></canvas>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const smap = document.getElementById('smap');
const sctx = smap.getContext('2d');

const status = document.getElementById('status');
const stats = document.getElementById('stats');
let debugMode = false;

const targetW = document.getElementById('targetW');
const gridStep = document.getElementById('gridStep');
const edgelThr = document.getElementById('edgelThr');
const ransacIter = document.getElementById('ransacIter');
const minSupport = document.getElementById('minSupport');
document.getElementById('tv').innerText = targetW.value;
document.getElementById('gs').innerText = gridStep.value;
document.getElementById('et').innerText = edgelThr.value;
document.getElementById('ri').innerText = ransacIter.value;
document.getElementById('ms').innerText = minSupport.value;

[targetW,gridStep,edgelThr,ransacIter,minSupport].forEach(el=>{
  el.oninput = ()=> {
    document.getElementById('tv').innerText = targetW.value;
    document.getElementById('gs').innerText = gridStep.value;
    document.getElementById('et').innerText = edgelThr.value;
    document.getElementById('ri').innerText = ransacIter.value;
    document.getElementById('ms').innerText = minSupport.value;
  };
});

document.getElementById('presetMobile').onclick = ()=>{
  targetW.value=480; gridStep.value=8; edgelThr.value=12; ransacIter.value=350; minSupport.value=10; updateLabels();
};
document.getElementById('presetPrinted').onclick = ()=>{
  targetW.value=640; gridStep.value=6; edgelThr.value=10; ransacIter.value=450; minSupport.value=12; updateLabels();
};
document.getElementById('toggleDebug').onclick = ()=>{ debugMode=!debugMode; };
document.getElementById('captureBtn').onclick = captureFrame;

function updateLabels(){ document.getElementById('tv').innerText=targetW.value; document.getElementById('gs').innerText=gridStep.value; document.getElementById('et').innerText=edgelThr.value; document.getElementById('ri').innerText=ransacIter.value; document.getElementById('ms').innerText=minSupport.value; }

async function startCamera(){
  try{
    const s = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    video.srcObject = s; await video.play();
    status.innerText='Camera ready';
    requestAnimationFrame(loop);
  }catch(e){ status.innerText='Camera error: '+e.message; console.error(e); }
}
startCamera();

// Sobel (same as earlier but small optimization)
function computeSobelGray(imgdata,w,h){
  const data = imgdata; // Uint8ClampedArray RGBA
  const gray = new Float32Array(w*h);
  for(let i=0, j=0;i<w*h;i++){ const idx=i*4; gray[i]=0.299*data[idx]+0.587*data[idx+1]+0.114*data[idx+2]; }
  const gx = new Float32Array(w*h), gy = new Float32Array(w*h), mag = new Float32Array(w*h);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const i=y*w+x;
      gx[i] = -gray[i-w-1] + gray[i-w+1] -2*gray[i-1] + 2*gray[i+1] - gray[i+w-1] + gray[i+w+1];
      gy[i] =  gray[i-w-1] + 2*gray[i-w] + gray[i-w+1] - gray[i+w-1] -2*gray[i+w] - gray[i+w+1];
      mag[i] = Math.hypot(gx[i], gy[i]);
    }
  }
  return {gray,gx,gy,mag};
}

function extractEdgels(sobel,w,h,step,thr){
  const edgels=[];
  for(let y=Math.floor(step/2); y<h; y+=step){
    for(let x=Math.floor(step/2); x<w; x+=step){
      const i=y*w+x, m=sobel.mag[i];
      if(m>=thr){
        // local max
        let isMax=true;
        for(let yy=-1; yy<=1 && isMax; yy++){
          for(let xx=-1; xx<=1; xx++){
            const nx=x+xx, ny=y+yy;
            if(nx>=0 && nx<w && ny>=0 && ny<h){
              if(sobel.mag[ny*w+nx] > m){ isMax=false; break; }
            }
          }
        }
        if(isMax) edgels.push({x,y,mag:m});
      }
    }
  }
  return edgels;
}

function ransacLines(edgels,params){
  const pts = edgels.slice(); const lines=[];
  if(pts.length>1200) pts.sort((a,b)=>b.mag-a.mag), pts.length=1200;
  const iters = params.ransacIters; const supportDist=params.supportDist||3; const angThresh=params.supportAngle||(22*Math.PI/180);
  while(pts.length>6 && lines.length < params.maxLines && iters>0){
    let best=null, bestSup=[];
    for(let it=0; it<iters; it++){
      const aIdx=Math.floor(Math.random()*pts.length), bIdx=Math.floor(Math.random()*pts.length);
      if(aIdx===bIdx) continue;
      const a=pts[aIdx], b=pts[bIdx];
      const dx=b.x-a.x, dy=b.y-a.y; const norm=Math.hypot(dx,dy); if(norm<1e-6) continue;
      const nx=dy/norm, ny=-dx/norm, c=-(nx*a.x+ny*a.y);
      const angleLine = Math.atan2(dy,dx);
      const sup=[];
      for(let i=0;i<pts.length;i++){
        const p=pts[i]; const dist=Math.abs(nx*p.x + ny*p.y + c);
        if(dist <= supportDist){
          let diff = Math.abs(p.ori ? (p.ori - angleLine) : 0);
          diff = Math.min(diff, Math.abs(Math.PI - diff));
          if(diff <= angThresh) sup.push(p);
        }
      }
      if(sup.length > bestSup.length){ bestSup = sup; best = {a,b,dx,dy}; }
    }
    if(!best || bestSup.length < params.minSupport) break;
    // compute mean, direction, endpoints
    const mean = bestSup.reduce((ac,p)=>{ac.x+=p.x;ac.y+=p.y;return ac},{x:0,y:0});
    mean.x/=bestSup.length; mean.y/=bestSup.length;
    const dir = {x: best.dx/Math.hypot(best.dx,best.dy), y: best.dy/Math.hypot(best.dx,best.dy)};
    let minP=Infinity, maxP=-Infinity;
    for(const p of bestSup){ const proj = ( (p.x-mean.x)*dir.x + (p.y-mean.y)*dir.y ); if(proj<minP) minP=proj; if(proj>maxP) maxP=proj; }
    const p1={x: mean.x + dir.x*minP, y: mean.y + dir.y*minP}, p2={x: mean.x + dir.x*maxP, y: mean.y + dir.y*maxP};
    lines.push({p1,p2,dir,supports:bestSup});
    // remove supports
    const set = new Set(bestSup);
    const newPts = []; for(const p of pts) if(!set.has(p)) newPts.push(p);
    pts.length=0; pts.push(...newPts);
    // safety break
    if(lines.length>params.maxLines) break;
  }
  return lines;
}

function intersect(p1,p2,p3,p4){
  const x1=p1.x,y1=p1.y,x2=p2.x,y2=p2.y,x3=p3.x,y3=p3.y,x4=p4.x,y4=p4.y;
  const denom=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
  if(Math.abs(denom)<1e-6) return null;
  const px = ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/denom;
  const py = ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/denom;
  return {x:px,y:py};
}

function orderQuad(pts){
  const cx=(pts[0].x+pts[1].x+pts[2].x+pts[3].x)/4;
  const cy=(pts[0].y+pts[1].y+pts[2].y+pts[3].y)/4;
  return pts.map(p=>({p,ang:Math.atan2(p.y-cy,p.x-cx)})).sort((a,b)=>a.ang-b.ang).map(o=>o.p);
}

function polygonArea(pts){ let a=0; for(let i=0;i<pts.length;i++){ const j=(i+1)%pts.length; a+=pts[i].x*pts[j].y-pts[j].x*pts[i].y;} return 0.5*a; }

let last = performance.now();
function loop(){
  if(video.readyState < 2){ requestAnimationFrame(loop); return; }
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  // processing scale
  const pW = parseInt(targetW.value,10);
  const scale = Math.min(1, pW / canvas.width);
  const procW = Math.max(120, Math.round(canvas.width * scale));
  const procH = Math.max(80, Math.round(canvas.height * scale));
  const tmp = document.createElement('canvas'); tmp.width=procW; tmp.height=procH;
  const tctx = tmp.getContext('2d'); tctx.drawImage(video,0,0,procW,procH);
  const img = tctx.getImageData(0,0,procW,procH);

  const sobel = computeSobelGray(img.data, procW, procH);
  // draw sobel magnitude small map
  sctx.clearRect(0,0,smap.width,smap.height);
  const smImg = sctx.createImageData(procW>140?140:procW, procH>100?100:procH);
  // scale to inset
  const sw = smImg.width, sh = smImg.height;
  for(let y=0;y<sh;y++){
    for(let x=0;x<sw;x++){
      const sx = Math.floor(x * procW / sw), sy = Math.floor(y * procH / sh);
      const v = Math.min(255, Math.round(sobel.mag[sy*procW + sx]));
      const idx=(y*sw+x)*4; smImg.data[idx]=v; smImg.data[idx+1]=v; smImg.data[idx+2]=v; smImg.data[idx+3]=255;
    }
  }
  sctx.putImageData(smImg,0,0);

  // edgels
  const gs = parseInt(gridStep.value,10);
  const thr = parseFloat(edgelThr.value);
  const edgels = extractEdgels(sobel, procW, procH, gs, thr);
  // auto-lower thr if too few edgels
  if(edgels.length < 18 && thr > 6){
    edgelThr.value = Math.max(6, thr - 1);
    document.getElementById('et').innerText = edgelThr.value;
  }

  // RANSAC
  const rparams = { ransacIters: parseInt(ransacIter.value,10), minSupport: parseInt(minSupport.value,10), maxLines: 14, supportDist:3, supportAngle:22*Math.PI/180 };
  // attach ori to edgels (approx from sobel) ~ here we set 0 (simple)
  for(const e of edgels){ e.ori = 0; } // we skip orientation test for now to be robust
  const lines = ransacLines(edgels, rparams);
  // simple merge (skip complex merging for perf)

  // extend lines (simple)
  const extended = lines.map(l=>{
    const dir = l.dir || {x:(l.p2.x-l.p1.x), y:(l.p2.y-l.p1.y)}; const dn = Math.hypot(dir.x,dir.y)||1; dir.x/=dn;dir.y/=dn;
    // step extend until mag small
    let p1 = {...l.p1}, p2 = {...l.p2};
    for(let k=0;k<120;k++){ const nx=Math.round(p1.x - dir.x*1.5), ny=Math.round(p1.y - dir.y*1.5); if(nx<=1||ny<=1||nx>=procW-2||ny>=procH-2) break; if(sobel.mag[ny*procW + nx] < 4) break; p1.x = nx; p1.y=ny;}
    for(let k=0;k<120;k++){ const nx=Math.round(p2.x + dir.x*1.5), ny=Math.round(p2.y + dir.y*1.5); if(nx<=1||ny<=1||nx>=procW-2||ny>=procH-2) break; if(sobel.mag[ny*procW + nx] < 4) break; p2.x = nx; p2.y=ny;}
    return {p1,p2,dir};
  });

  // find quads (brute force)
  const quads = [];
  for(let i=0;i<extended.length;i++){
    for(let j=i+1;j<extended.length;j++){
      for(let k=j+1;k<extended.length;k++){
        for(let l=k+1;l<extended.length;l++){
          const L=[extended[i],extended[j],extended[k],extended[l]];
          const perms = [[0,1,2,3],[0,2,1,3],[0,1,3,2],[0,3,1,2]]; // few perms
          for(const perm of perms){
            const pts=[];
            let ok=true;
            for(let t=0;t<4;t++){
              const a=L[perm[t]], b=L[perm[(t+1)%4]];
              const p = intersect(a.p1,a.p2,b.p1,b.p2);
              if(!p){ ok=false; break; }
              pts.push(p);
            }
            if(!ok) continue;
            const ordered = orderQuad(pts);
            if(Math.abs(polygonArea(ordered)) < 80) continue;
            if(!ordered) continue;
            quads.push({pts:ordered});
          }
        }
      }
    }
  }

  // draw results scaled to display
  const scaleInv = canvas.width / procW;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  // draw edgels if debug
  if(debugMode){
    ctx.fillStyle='yellow';
    for(const e of edgels) ctx.fillRect(e.x*scaleInv-1,e.y*scaleInv-1,3,3);
  }

  // draw lines
  ctx.lineWidth=3; ctx.strokeStyle='cyan';
  for(const L of extended){
    ctx.beginPath(); ctx.moveTo(L.p1.x*scaleInv, L.p1.y*scaleInv); ctx.lineTo(L.p2.x*scaleInv, L.p2.y*scaleInv); ctx.stroke();
  }

  // draw quads
  ctx.lineWidth=4; ctx.strokeStyle='orange';
  for(const q of quads){
    ctx.beginPath(); ctx.moveTo(q.pts[0].x*scaleInv,q.pts[0].y*scaleInv);
    for(let ii=1; ii<4; ii++) ctx.lineTo(q.pts[ii].x*scaleInv,q.pts[ii].y*scaleInv);
    ctx.closePath(); ctx.stroke();
    ctx.fillStyle='yellow'; for(const p of q.pts) ctx.beginPath(), ctx.arc(p.x*scaleInv,p.y*scaleInv,6,0,Math.PI*2), ctx.fill();
  }

  const now = performance.now(); const fps = Math.round(1000/(now-last)); last=now;
  stats.innerText = `edgels:${edgels.length} lines:${extended.length} quads:${quads.length} fps:${fps}`;
  status.innerText = `procW:${procW} procH:${procH} scale:${scale.toFixed(2)}`;

  requestAnimationFrame(loop);
}

function captureFrame(){
  const data = canvas.toDataURL('image/png');
  const a = document.createElement('a'); a.href=data; a.download='capture.png'; a.click();
}

</script>
</body>
</html>
