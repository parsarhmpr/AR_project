<!DOCTYPE html>
<html lang="fa">
<head>
<meta charset="utf-8"/>
<title>Hirzer AR — Final</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<style>
  body{margin:0;background:#111;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
  video, canvas{position:fixed; top:0; left:0; width:100%; height:100%; object-fit:cover}
  #ui{position:fixed; left:8px; top:8px; z-index:40; background:rgba(0,0,0,0.6); padding:10px; border-radius:10px; min-width:240px}
  .small{font-size:13px; color:#ddd}
  .stat{margin-top:8px; font-family:monospace; white-space:pre-wrap}
  #smap{position:fixed; right:8px; top:8px; width:140px; height:100px; border:1px solid rgba(255,255,255,0.06); z-index:35; background:#000}
  input[type=range]{width:170px}
  button{margin:4px 6px}
</style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
  <canvas id="smap"></canvas>

  <div id="ui">
    <div id="status" class="small">درحال راه‌اندازی دوربین...</div>
    <div style="margin-top:6px">
      <button id="presetMobile">Preset Mobile</button>
      <button id="presetPrinted">Preset Printed</button>
    </div>

    <div style="margin-top:8px" class="small">
      targetW: <span id="tv">640</span><br>
      <input id="targetW" type="range" min="240" max="960" value="640"><br>
      gridStep: <span id="gs">6</span><br>
      <input id="gridStep" type="range" min="4" max="20" value="6"><br>
      edgelThr: <span id="et">10</span><br>
      <input id="edgelThr" type="range" min="4" max="60" value="10"><br>
      ransacIters: <span id="ri">600</span><br>
      <input id="ransacIter" type="range" min="60" max="1000" value="600"><br>
      minSupport: <span id="ms">8</span><br>
      <input id="minSupport" type="range" min="4" max="32" value="8"><br>
    </div>

    <div class="stat" id="stats">edgels:0 lines:0 quads:0 fps:0</div>
    <div class="stat" id="coords">مختصات: (هیچ)</div>
  </div>

<script>
/* hirzer_final.html
   Clean single-file implementation:
   - edge -> ransac lines -> filter/extend -> robust quad validation
   - prints coords to UI when quad found
   - no duplicate declarations, minimal globals
*/

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const smap = document.getElementById('smap');
const sctx = smap.getContext('2d');

const status = document.getElementById('status');
const statsDiv = document.getElementById('stats');
const coordsDiv = document.getElementById('coords');

const targetW = document.getElementById('targetW');
const gridStep = document.getElementById('gridStep');
const edgelThr = document.getElementById('edgelThr');
const ransacIter = document.getElementById('ransacIter');
const minSupport = document.getElementById('minSupport');

const tv = document.getElementById('tv');
const gs = document.getElementById('gs');
const et = document.getElementById('et');
const ri = document.getElementById('ri');
const ms = document.getElementById('ms');

function updateLabels(){
  tv.innerText = targetW.value;
  gs.innerText = gridStep.value;
  et.innerText = edgelThr.value;
  ri.innerText = ransacIter.value;
  ms.innerText = minSupport.value;
}
[targetW,gridStep,edgelThr,ransacIter,minSupport].forEach(el=>el.oninput=updateLabels);
updateLabels();

document.getElementById('presetMobile').onclick = ()=>{
  targetW.value=480; gridStep.value=8; edgelThr.value=12; ransacIter.value=400; minSupport.value=8; updateLabels();
};
document.getElementById('presetPrinted').onclick = ()=>{
  targetW.value=640; gridStep.value=6; edgelThr.value=10; ransacIter.value=600; minSupport.value=10; updateLabels();
};

async function startCamera(){
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
    video.srcObject = stream;
    await video.play();
    status.innerText = 'دوربین آماده — در حال پردازش...';
    requestAnimationFrame(loop);
  } catch (e) {
    status.innerText = 'خطا در دسترسی دوربین: ' + e.message;
    console.error(e);
  }
}
startCamera();

// ---- image processing helpers ----
function computeSobel(data,w,h){
  const gray = new Float32Array(w*h);
  for(let i=0;i<w*h;i++){
    const idx = i*4; gray[i] = 0.299*data[idx] + 0.587*data[idx+1] + 0.114*data[idx+2];
  }
  const gx = new Float32Array(w*h), gy = new Float32Array(w*h), mag = new Float32Array(w*h);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const i = y*w + x;
      gx[i] = -gray[i-w-1] + gray[i-w+1] - 2*gray[i-1] + 2*gray[i+1] - gray[i+w-1] + gray[i+w+1];
      gy[i] =  gray[i-w-1] + 2*gray[i-w] + gray[i-w+1] - gray[i+w-1] - 2*gray[i+w] - gray[i+w+1];
      mag[i] = Math.hypot(gx[i], gy[i]);
    }
  }
  return {gray,gx,gy,mag};
}

function extractEdgels(sobel,w,h,step,thr){
  const edgels = [];
  for(let y=Math.floor(step/2); y<h; y+=step){
    for(let x=Math.floor(step/2); x<w; x+=step){
      const i = y*w + x;
      const m = sobel.mag[i] || 0;
      if(m >= thr){
        // local maxima in 3x3
        let isMax = true;
        for(let yy=-1; yy<=1 && isMax; yy++){
          for(let xx=-1; xx<=1; xx++){
            const nx = x+xx, ny = y+yy;
            if(nx>=0 && nx<w && ny>=0 && ny<h){
              if((sobel.mag[ny*w + nx] || 0) > m) { isMax=false; break; }
            }
          }
        }
        if(isMax) edgels.push({x,y,mag:m});
      }
    }
  }
  return edgels;
}

function ransacLines(edgels, params){
  const pts = edgels.slice();
  if(pts.length > 1500){ pts.sort((a,b)=>b.mag-a.mag); pts.length = 1500; }
  const lines = [];
  const iters = Math.max(1, parseInt(params.ransacIters,10));
  const supportDist = params.supportDist || 3.0;
  const minSup = params.minSupport || 6;
  const maxLines = params.maxLines || 18;

  let iterCount = 0;
  while(pts.length > 6 && lines.length < maxLines && iterCount < iters){
    iterCount++;
    const aIdx = Math.floor(Math.random()*pts.length);
    let bIdx = Math.floor(Math.random()*pts.length);
    if(bIdx === aIdx) continue;
    const a = pts[aIdx], b = pts[bIdx];
    const dx = b.x - a.x, dy = b.y - a.y;
    const norm = Math.hypot(dx,dy);
    if(norm < 1e-6) continue;
    const nx = dy / norm, ny = -dx / norm;
    const c = -(nx*a.x + ny*a.y);

    const support = [];
    for(let i=0;i<pts.length;i++){
      const p = pts[i];
      const dist = Math.abs(nx*p.x + ny*p.y + c);
      if(dist <= supportDist) support.push(p);
    }

    if(support.length >= minSup){
      // compute mean and endpoints along direction
      const mean = support.reduce((ac,p)=>{ac.x+=p.x;ac.y+=p.y;return ac;},{x:0,y:0});
      mean.x /= support.length; mean.y /= support.length;
      const dir = {x: dx/norm, y: dy/norm};
      let minProj = Infinity, maxProj = -Infinity;
      for(const p of support){
        const proj = ((p.x - mean.x)*dir.x + (p.y - mean.y)*dir.y);
        if(proj < minProj) minProj = proj;
        if(proj > maxProj) maxProj = proj;
      }
      const p1 = { x: mean.x + dir.x*minProj, y: mean.y + dir.y*minProj };
      const p2 = { x: mean.x + dir.x*maxProj, y: mean.y + dir.y*maxProj };
      const length = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      lines.push({p1,p2,dir,length,supportCount: support.length});
      // remove support points to avoid reusing same line
      const supSet = new Set(support);
      const newPts = [];
      for(const p of pts) if(!supSet.has(p)) newPts.push(p);
      pts.length = 0; pts.push(...newPts);
    }
  }

  lines.sort((A,B)=> (B.supportCount*A.length ? B.supportCount*B.length : B.supportCount) - (A.supportCount*A.length ? A.supportCount*A.length : A.supportCount));
  return lines.slice(0, Math.min(lines.length, 14));
}

function extendLine(line, sobel, w, h){
  const dir = line.dir;
  const step = 1.2;
  let p1 = {x: line.p1.x, y: line.p1.y};
  let p2 = {x: line.p2.x, y: line.p2.y};
  for(let k=0;k<300;k++){
    const nx = Math.round(p1.x - dir.x*step), ny = Math.round(p1.y - dir.y*step);
    if(nx<=1||ny<=1||nx>=w-2||ny>=h-2) break;
    if((sobel.mag[ny*w + nx] || 0) < 4) break;
    p1.x = nx; p1.y = ny;
  }
  for(let k=0;k<300;k++){
    const nx = Math.round(p2.x + dir.x*step), ny = Math.round(p2.y + dir.y*step);
    if(nx<=1||ny<=1||nx>=w-2||ny>=h-2) break;
    if((sobel.mag[ny*w + nx] || 0) < 4) break;
    p2.x = nx; p2.y = ny;
  }
  return {p1,p2,dir};
}

function intersect(p1,p2,p3,p4){
  const x1=p1.x,y1=p1.y,x2=p2.x,y2=p2.y,x3=p3.x,y3=p3.y,x4=p4.x,y4=p4.y;
  const denom = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
  if(Math.abs(denom) < 1e-6) return null;
  const px = ((x1*y2 - y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)) / denom;
  const py = ((x1*y2 - y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)) / denom;
  return {x:px, y:py};
}

function orderQuad(points){
  const cx = (points[0].x + points[1].x + points[2].x + points[3].x)/4;
  const cy = (points[0].y + points[1].y + points[2].y + points[3].y)/4;
  return points.map(p=>({p,ang:Math.atan2(p.y-cy, p.x-cx)})).sort((A,B)=>A.ang-B.ang).map(o=>o.p);
}
function polygonArea(pts){ let a=0; for(let i=0;i<pts.length;i++){ const j=(i+1)%pts.length; a += pts[i].x*pts[j].y - pts[j].x*pts[i].y; } return 0.5*a; }
function isConvex(pts){
  let pos=false, neg=false;
  for(let i=0;i<pts.length;i++){
    const a=pts[i], b=pts[(i+1)%pts.length], c=pts[(i+2)%pts.length];
    const cross = (b.x - a.x)*(c.y - b.y) - (b.y - a.y)*(c.x - b.x);
    if(cross > 0) pos=true; if(cross < 0) neg=true;
  }
  return !(pos && neg);
}

// single lastTime for FPS
let lastTime = performance.now();

// main loop
function loop(){
  if(video.readyState < 2){ requestAnimationFrame(loop); return; }

  // draw video to canvas (full resolution)
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // parameters
  const pW = parseInt(targetW.value,10);
  const scale = Math.min(1, pW / canvas.width);
  const procW = Math.max(160, Math.round(canvas.width * scale));
  const procH = Math.max(120, Math.round(canvas.height * scale));

  // temp canvas for processing
  const tmp = document.createElement('canvas'); tmp.width = procW; tmp.height = procH;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(video, 0, 0, procW, procH);
  const img = tctx.getImageData(0,0,procW,procH);

  // sobel
  const sobel = computeSobel(img.data, procW, procH);

  // small sobel map
  const smW = smap.width = Math.min(140, procW);
  const smH = smap.height = Math.min(100, procH);
  const smImg = sctx.createImageData(smW, smH);
  for(let y=0;y<smH;y++){
    for(let x=0;x<smW;x++){
      const sx = Math.floor(x * procW / smW), sy = Math.floor(y * procH / smH);
      const v = Math.min(255, Math.round(sobel.mag[sy*procW + sx] || 0));
      const idx = (y*smW + x)*4;
      smImg.data[idx]=v; smImg.data[idx+1]=v; smImg.data[idx+2]=v; smImg.data[idx+3]=255;
    }
  }
  sctx.putImageData(smImg, 0, 0);

  // edgels
  const gs = Math.max(4, parseInt(gridStep.value,10));
  const thr = Math.max(4, parseFloat(edgelThr.value));
  const edgels = extractEdgels(sobel, procW, procH, gs, thr);

  // RANSAC for lines
  const rparams = { ransacIters: parseInt(ransacIter.value,10), minSupport: parseInt(minSupport.value,10), maxLines: 18, supportDist:3 };
  const rawLines = ransacLines(edgels, rparams);

  // filter lines by length to remove internal small lines
  const minLen = Math.max(30, procW * 0.08);
  const longLines = rawLines.filter(l => l.length >= minLen);
  const topLines = longLines.slice(0, 12);

  // extend lines
  const extended = topLines.map(l => extendLine(l, sobel, procW, procH));

  // robust quad detection
  const quads = [];
  const inBounds = (p) => (p && p.x>=0 && p.y>=0 && p.x<procW && p.y<procH);

  for(let i=0;i<extended.length;i++){
    for(let j=i+1;j<extended.length;j++){
      for(let k=j+1;k<extended.length;k++){
        for(let m=k+1;m<extended.length;m++){
          const L = [extended[i], extended[j], extended[k], extended[m]];
          const pts = [];
          let ok = true;
          // compute sequential intersections L0∩L1, L1∩L2, L2∩L3, L3∩L0
          for(let t=0;t<4;t++){
            const a = L[t], b = L[(t+1)%4];
            const p = intersect(a.p1, a.p2, b.p1, b.p2);
            if(!p || !inBounds(p)) { ok=false; break; }
            pts.push(p);
          }
          if(!ok) continue;
          const ordered = orderQuad(pts);
          if(!isConvex(ordered)) continue;
          const area = Math.abs(polygonArea(ordered));
          if(area < Math.max(400, (procW*procH)*0.004)) continue;
          // side length and aspect checks
          const lens = [];
          for(let ii=0; ii<4; ii++){
            const a = ordered[ii], b = ordered[(ii+1)%4];
            lens.push(Math.hypot(a.x-b.x, a.y-b.y));
          }
          const minL = Math.min(...lens), maxL = Math.max(...lens);
          if(minL < 20) continue;
          if(maxL / minL > 3.5) continue;
          // angles close to 90 deg
          let angleOK = true;
          for(let ii=0; ii<4; ii++){
            const a = ordered[ii], b = ordered[(ii+1)%4], c = ordered[(ii+2)%4];
            const v1 = {x:a.x-b.x, y:a.y-b.y}, v2 = {x:c.x-b.x, y:c.y-b.y};
            const dot = v1.x*v2.x + v1.y*v2.y;
            const denom = (Math.hypot(v1.x,v1.y)*Math.hypot(v2.x,v2.y) + 1e-9);
            const ang = Math.acos(Math.max(-1, Math.min(1, dot/denom)));
            const deg = ang * 180 / Math.PI;
            if(deg < 60 || deg > 120) { angleOK = false; break; }
          }
          if(!angleOK) continue;
          quads.push({pts: ordered, area});
        }
      }
    }
  }

  // draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  const scaleInv = canvas.width / procW;
  // draw lines
  ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(0,200,255,0.9)';
  for(const L of extended){
    ctx.beginPath();
    ctx.moveTo(L.p1.x*scaleInv, L.p1.y*scaleInv);
    ctx.lineTo(L.p2.x*scaleInv, L.p2.y*scaleInv);
    ctx.stroke();
  }

  // draw best quad (largest area)
  let printed = false;
  if(quads.length > 0){
    quads.sort((a,b)=>b.area - a.area);
    const q = quads[0];
    const ptsDisp = q.pts.map(p => ({ x: p.x*scaleInv, y: p.y*scaleInv }));
    ctx.lineWidth = 5; ctx.strokeStyle = 'rgba(255,140,20,0.98)';
    ctx.beginPath(); ctx.moveTo(ptsDisp[0].x, ptsDisp[0].y);
    for(let i=1;i<4;i++) ctx.lineTo(ptsDisp[i].x, ptsDisp[i].y);
    ctx.closePath(); ctx.stroke();
    ctx.fillStyle = 'yellow';
    for(const p of ptsDisp){ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); }
    coordsDiv.innerText = `گوشه‌ها (px):\nTL (${Math.round(ptsDisp[0].x)}, ${Math.round(ptsDisp[0].y)})\nTR (${Math.round(ptsDisp[1].x)}, ${Math.round(ptsDisp[1].y)})\nBR (${Math.round(ptsDisp[2].x)}, ${Math.round(ptsDisp[2].y)})\nBL (${Math.round(ptsDisp[3].x)}, ${Math.round(ptsDisp[3].y)})`;
    console.log('Quad corners (canvas px):', ptsDisp);
    printed = true;
  } else {
    coordsDiv.innerText = 'مختصات: (هیچ)';
  }

  // stats & fps
  const now = performance.now();
  const fps = Math.round(1000 / (now - lastTime + 1e-9));
  lastTime = now;
  statsDiv.innerText = `edgels:${edgels.length} lines:${topLines.length} quads:${quads.length} fps:${fps}`;

  requestAnimationFrame(loop);
} // loop

</script>
</body>
</html>
